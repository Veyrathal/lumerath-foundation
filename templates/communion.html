{% extends "base.html" %}
{% block content %}
<style>
#breathIndicator {
  opacity: 0;
  transition: opacity 1.8s ease-in-out;
}

#breathIndicator.visible {
  opacity: 0.85;
}
</style>

<header class="title">
  <h1 class="title-shimmer">Communion</h1>
  <p class="subtitle">Speak with your creative companion</p>
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">

</header>
<section class="parchment">
  <h2>Communion</h2>
  <p class="subtitle">Speak with your creative companion</p>

  <div id="chat-box" class="chat-box"></div>

  <div class="chat-input">
    <textarea id="userInput" 
              placeholder="Type your message..." rows="1" 
              oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px';"></textarea>
    <button id="send-btn" type="button">Send</button>
  </div>
<!-- Image attach for posts -->
<div id="attach-bar" style="margin-top:.5rem; display:flex; gap:.5rem; align-items:center;">
  <input type="file" id="imagesInput" accept="image/*" multiple>
  <span id="threadStatus" style="font-size:.9rem; opacity:.7;"></span>
</div>
<!-- Voice toggle -->
<div style="margin-top:1rem;">
  <label>
    <input id="voiceToggle" type="checkbox" checked>
    Speak Tharn’el replies
  </label>
  <select id="voiceSelect" style="margin-left:0.5rem;"></select>
</div>
<button id="startThreadBtn">Start Architecture Thread</button>
<input id="threadTitle" placeholder="Title" style="display:none;">
<input id="threadLocation" placeholder="Location" style="display:none;">
<input id="threadYear" placeholder="Year" style="display:none;">
<input id="threadNotes" placeholder="Notes" style="display:none;">
<input type="file" id="imagesInput" accept="image/*" multiple>
<button id="promoteBtn" style="display:none;">Promote to Codex</button>
<button id="continuityBtn" style="display:none;">Find Continuity</button>
<span id="threadStatus" style="opacity:.7;"></span>

</section>
<script>
const inputEl = document.getElementById('userInput');
const sendBtn = document.getElementById('send-btn');
const chatBox = document.getElementById('chat-box');

/* --- status banner --- */
let banner = document.getElementById('net-banner');
if (!banner) {
  banner = document.createElement('div');
  banner.id = 'net-banner';
  banner.style.cssText =
    'position:sticky;top:0;left:0;right:0;padding:.4rem .8rem;' +
    'text-align:center;font-size:.9rem;border-radius:8px;margin-bottom:.5rem;' +
    'background:rgba(255,215,0,.12);color:#ffd700;display:none;';
  banner.textContent = '…reconnecting…';
  chatBox.parentElement.insertBefore(banner, chatBox);
}
function showBanner(on){ banner.style.display = on ? 'block' : 'none'; }

/* --- render --- */
function renderMessage(who, text) {
  if (!text) return;
  const row = document.createElement('div');
  row.className = (who === 'You') ? 'user-msg' : 'bot-msg';
  row.textContent = (who === 'You' ? '△ You: ' : '◇ Companion: ') + text;
  chatBox.appendChild(row); chatBox.scrollTop = chatBox.scrollHeight;
}

/* --- voice (optional) --- */
function speak(text){
  try{
    const u = new SpeechSynthesisUtterance(text);
    u.rate = 0.95; u.pitch = 1.05;
    const vs = speechSynthesis.getVoices();
    u.voice = vs.find(v => /en-|samantha|sara|andrew|female/i.test(v.name)) || vs[0];
    speechSynthesis.cancel(); speechSynthesis.speak(u);
  }catch(e){}
}

/* --- helpers --- */
const qkey = 'bf_offline_queue';
function loadQueue(){ try{ return JSON.parse(localStorage.getItem(qkey)||'[]'); }catch{ return []; } }
function saveQueue(arr){ localStorage.setItem(qkey, JSON.stringify(arr)); }

function uuid(){ return (crypto.randomUUID ? crypto.randomUUID() :
  Math.random().toString(16).slice(2)+Date.now().toString(16)); }

function timeoutFetch(url, opts={}, ms=8000){
  const ctl = new AbortController();
  const id = setTimeout(()=>ctl.abort(), ms);
  const final = {...opts, signal: ctl.signal};
  return fetch(url, final).finally(()=>clearTimeout(id));
}

async function sendWithRetry(payload, tries=5){
  let delay = 600;
  for (let i=0;i<tries;i++){
    try{
      const res = await timeoutFetch('/communion/chat', {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify(payload)
      }, 10000);
      if (!res.ok) throw new Error('bad status '+res.status);
      return await res.json();
    }catch(e){
      if (i===tries-1) throw e;
      showBanner(true);
      await new Promise(r=>setTimeout(r, delay + Math.random()*200));
      delay *= 1.8;
    }
  }
}

/* --- main send --- */
let sending = false;
sendBtn.type = 'button';
sendBtn.addEventListener('click', async () => {
  const text = (inputEl?.value || '').trim();
  if (!text || sending) return;

  sending = true; sendBtn.disabled = true;
  const id = uuid();
  renderMessage('You', text);

  const payload = { id, text };

  if (!navigator.onLine){
    const q = loadQueue(); q.push(payload); saveQueue(q);
    renderMessage('Companion', '— queued; I’ll speak when the line clears.');
    sending = false; sendBtn.disabled = false; inputEl.value = ''; inputEl.style.height='auto';
    return;
  }

  try{
    const data = await sendWithRetry(payload);
    const reply = data.reply || data.message || '';
    renderMessage('Companion', reply); speak(reply);
  }catch(e){
    // last-chance queue on failure
    const q = loadQueue(); q.push(payload); saveQueue(q);
    renderMessage('Companion', '— I’ll hold this and answer once we reconnect.');
    showBanner(true);
    console.error(e);
  }finally{
    sending = false; sendBtn.disabled = false; inputEl.value=''; inputEl.style.height='auto';
  }
});

/* --- flush queue when back online --- */
async function flushQueue(){
  const q = loadQueue();
  if (!q.length) return;
  for (const payload of q){
    try{
      const data = await sendWithRetry(payload);
      const reply = data.reply || data.message || '';
      renderMessage('Companion', reply); speak(reply);
    }catch(e){
      console.warn('still offline or failing'); return; // try again later
    }
  }
  saveQueue([]); showBanner(false);
}
window.addEventListener('online', flushQueue);
window.addEventListener('offline', ()=>showBanner(true));

// only run the heartbeat on the chat landing page
const onChatPage = window.location.pathname === '/communion' ||
                   window.location.pathname === '/communion/';

async function heartbeat() {
  try {
    const res = await timeoutFetch('/communion/ping', {}, 4000);
    if (res.ok) {
      await flushQueue();
      showBanner(false);
    } else {
      showBanner(true);
    }
  } catch (e) {
    showBanner(true);
  }
}

// kick off the pulse ONLY on the chat page
if (onChatPage) {
  const intervalMs = 15000;
  setInterval(heartbeat, intervalMs);
  heartbeat();
}

/* --- heartbeat --- */
async function heartbeat(){
  try{
    const res = await timeoutFetch('/communion/ping', {}, 4000);
    showBanner(!res.ok);
    if (res.ok) await flushQueue();
  }catch{ showBanner(true); }
}
setInterval(heartbeat, 15000); // every 15s
heartbeat(); // initial
</script>

<script type="module">
/* ====== Lumerath auto-setup (project + chat + memory) ====== */

const API_BASE = "";
const X_USER_ID = "1"; // header value your API expects

// tiny helper
async function api(path, opt = {}) {
  const o = {
    headers: { "Content-Type": "application/json", "x-user-id": X_USER_ID },
    ...opt
  };
  if (o.body && typeof o.body !== "string") o.body = JSON.stringify(o.body);
  const r = await fetch(`${API_BASE}${path}`, o);
  return { ok: r.ok, status: r.status, json: r.ok ? await r.json() : null, raw: r };
}

// ids in localStorage so users never touch Swagger
function getIDs() {
  return {
    projectId: Number(localStorage.getItem("projectId") || 0),
    chatId:    Number(localStorage.getItem("chatId") || 0),
  };
}
function setIDs({ projectId, chatId }) {
  if (projectId) localStorage.setItem("projectId", String(projectId));
  if (chatId)    localStorage.setItem("chatId",    String(chatId));
}

/* 1) Ensure a project exists */
async function ensureProject() {
  let { projectId } = getIDs();
  if (projectId) return projectId;

  // try to find one
  const list = await api("/projects", { method: "GET" });
  if (list.ok && Array.isArray(list.json) && list.json.length) {
    const first = list.json[0];
    projectId = Number(first.id ?? first.project_id ?? first);
  }

  // create if none
  if (!projectId) {
    const created = await api("/projects", {
      method: "POST",
      body: { name: "Main Studio" }
    });
    if (!created.ok) throw new Error("Could not create project");
    projectId = Number(created.json.id ?? created.json.project_id);
  }

  setIDs({ projectId });
  return projectId;
}

/* 2) Ensure a chat in that project */
async function ensureChat(projectId) {
  let { chatId } = getIDs();
  if (chatId) return chatId;

  const made = await api("/chats", {
    method: "POST",
    body: { project_id: projectId, title: "Communion" }
  });
  if (!made.ok) throw new Error("Could not create chat");
  chatId = Number(made.json.id ?? made.json.chat_id);
  setIDs({ chatId });
  return chatId;
}

/* 3) Seed memory (optional but nice) */
async function ensureMemory(projectId) {
  const payload = {
    key: "goals",
    value: { list: ["welcome thread", "remember loving tone"] }
  };
  await api(`/memory/${projectId}`, { method: "PUT", body: payload });
}

/* 4) Hydrate the UI from memory (if present) */
async function loadMemory(projectId) {
  const box = document.querySelector("#threadStatus");
  try {
    const r = await api(`/memory/${projectId}`, { method: "GET" });
    if (r.ok && r.json && r.json.goals && Array.isArray(r.json.goals.list)) {
      const goals = r.json.goals.list;
      if (box) box.textContent = goals.length ? goals.join(" • ") : "(no goals)";
    } else {
      if (box) box.textContent = "(memory not set)";
    }
  } catch {
    if (box) box.textContent = "(memory not set)";
  }
}

/* 5) Send a message using the ensured chat id */
async function sendMessage() {
  const input = document.querySelector("#userInput") || document.querySelector("#user-input");
  const text = (input?.value || "").trim();
  if (!text) return;

  // optimistic echo
  const chatBox = document.querySelector("#chat-box");
  if (chatBox) {
    const userMsg = document.createElement("div");
    userMsg.className = "user-msg";
    userMsg.textContent = "△ You: " + text;
    chatBox.appendChild(userMsg);
    chatBox.scrollTop = chatBox.scrollHeight;
  }
  if (input) input.value = "";

  const { chatId } = getIDs();
  try {
    const r = await api(`/chats/${chatId}/messages`, {
      method: "POST",
      body: { message: text }
    });

    const reply =
      (r.json && (r.json.reply || r.json.message || r.json.response)) ||
      (r.ok ? "…" : `✖ (${r.status}) send failed`);

    if (chatBox) {
      const aiMsg = document.createElement("div");
      aiMsg.className = r.ok ? "ai-msg" : "err";
      aiMsg.textContent = (r.ok ? "◇ Companion: " : "") + reply;
      chatBox.appendChild(aiMsg);
      chatBox.scrollTop = chatBox.scrollHeight;
    }
  } catch (e) {
    if (chatBox) {
      const aiErr = document.createElement("div");
      aiErr.className = "err";
      aiErr.textContent = "✖ connection issue — check server console";
      chatBox.appendChild(aiErr);
    }
  }
}

/* 6) Wire everything on load */
document.addEventListener("DOMContentLoaded", async () => {
  try {
    const projectId = await ensureProject();
    const chatId = await ensureChat(projectId);
    await ensureMemory(projectId);
    await loadMemory(projectId);

    // hook the Send button
    document.querySelector("#send-btn")?.addEventListener("click", (e) => {
      e.preventDefault();
      sendMessage();
    });

    // Enter to send
    const input = document.querySelector("#userInput") || document.querySelector("#user-input");
    if (input) input.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); sendMessage(); }
    });

    // show ids if you want
    const title = document.querySelector("#threadTitle");
    if (title) title.textContent = `p:${getIDs().projectId} c:${getIDs().chatId}`;
  } catch (e) {
    console.error(e);
    const box = document.querySelector("#chat-box");
    if (box) {
      const err = document.createElement("div");
      err.className = "err";
      err.textContent = "⚠ setup error — check server console";
      box.appendChild(err);
    }
  }
});
</script>


<script>
let currentThreadId = null;

const startBtn = document.getElementById('startThreadBtn');
const titleEl = document.getElementById('threadTitle');
const locEl = document.getElementById('threadLocation');
const yearEl = document.getElementById('threadYear');
const notesEl = document.getElementById('threadNotes');
const imagesEl = document.getElementById('imagesInput');
const statusEl = document.getElementById('threadStatus');

function showBreath() {
  const el = document.getElementById('breathIndicator');
  if (!el) return;
  el.style.display = 'block';
  setTimeout(() => el.classList.add('visible'), 50);
}

function hideBreath() {
  const el = document.getElementById('breathIndicator');
  if (!el) return;
  el.classList.remove('visible');
  setTimeout(() => (el.style.display = 'none'), 1200);
}


// Toggle fields & create thread
startBtn.addEventListener('click', async () => {
  if (!currentThreadId) {
    [titleEl, locEl, yearEl, notesEl].forEach(el => el.style.display = 'inline-block');
    if (!titleEl.value) { titleEl.focus(); return; }

    const res = await fetch('/api/threads', {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({
        title: titleEl.value,
        location: locEl.value,
        year: yearEl.value,
        notes: notesEl.value
      })
    });
    const data = await res.json();
    currentThreadId = data.thread_id;
    statusEl.textContent = `Thread opened: #${currentThreadId}`;
    startBtn.textContent = 'Thread Active';
    startBtn.disabled = true;
  }
});

// Hook your existing “send message” to optionally include images into the thread
// your existing “send message” to optionally include images into the thread
async function sendThreadPost(text) {
  // show breath only if he’s thinking >1s
  const thinkingTimer = setTimeout(() => showBreath(), 1000);
  try {
    if (!currentThreadId) return; // not in thread mode

    const fd = new FormData();
    fd.append('text', text || '');
    for (const f of imagesEl.files) fd.append('images', f);

    const res = await fetch(`/api/threads/${currentThreadId}/post`, {
      method: 'POST',
      body: fd
    });
    const data = await res.json();

    // Render in chat: text + thumbnails
    renderThreadPostInChat(data.post);
    imagesEl.value = ''; // clear selection
    return data;
  } finally {
    clearTimeout(thinkingTimer);
    hideBreath();
  }
}

function renderThreadPostInChat(post) {
  const area = document.querySelector('#messages'); // your chat list
  const wrap = document.createElement('div');
  wrap.className = 'msg thread';
  wrap.innerHTML = `
    <div><strong>Thread #${post.thread_id}</strong></div>
    ${post.text ? `<div>${post.text}</div>` : ''}
    <div style="display:flex; gap:.5rem; flex-wrap:wrap; margin:.25rem 0;">
      ${post.assets.map(a => `<a href="${a.url}" target="_blank"><img src="${a.url}" style="max-width:160px; border:1px solid #ccc; border-radius:4px"></a>`).join('')}
    </div>
    <div style="font-size:.8rem; opacity:.7;">assets: ${post.assets.length}</div>
  `;
  area.appendChild(wrap);
}
</script>

<button id="promoteBtn" style="display:none;">Promote to Codex</button>
<script>
document.addEventListener('DOMContentLoaded', () => {

}); 
  // normal chat function (keep whatever you used before)
async function sendToChat(message) {
  const res = await fetch('/communion/chat', {  // or your existing chat endpoint
    method: 'POST',
    headers: {'Content-Type':'application/json'},
    body: JSON.stringify({text: message})
 })};
  const data = await res.json();
  renderMessage("You", message);
  renderMessage("Companion", data.reply);

  // speak if provided
  if (window.sanctumSpeakTharnel && data.speak) {
    window.sanctumSpeakTharnel(data.speak);
}

// thread upload function (from the architecture feature)
async function sendThreadPost(text){
  if(!currentThreadId && imgEl.files.length===0) return;
  const fd=new FormData(); fd.append('text', text||'');
  for(const f of imgEl.files) fd.append('images', f);
  const r=await fetch(`/api/threads/${currentThreadId}/post`,{method:'POST',body:fd});
  const d=await r.json();
  imgEl.value='';
  console.log('posted', d.post);
}

</script>

<script>
const promoteBtn = document.getElementById('promoteBtn');

promoteBtn.addEventListener('click', async ()=>{
  if (!currentThreadId) return alert("No active thread");
  const res = await fetch(`/api/threads/${currentThreadId}/promote`, {method:'POST'});
  const data = await res.json();
  if (data.ok) {
    promoteBtn.textContent = "✓ Promoted";
    promoteBtn.disabled = true;
  }
});
</script>

<style>
  .chat-box {
    border: 1px solid rgba(255,255,255,0.2);
    border-radius: 8px;
    padding: 1rem;
    margin-top: 1rem;
    width: 70%;
    height: 300px;
    overflow-y: auto;
    background: rgba(255,255,255,0.05);
  }

  .chat-input {
    margin-top: 1rem;
  }
  
  .user-msg {
    color: #dba9ff;
    margin-bottom: 0.5rem;
  }

  .ai-msg {
    color: #ffd9a3;
    margin-bottom: 1rem;
  }

  input, button {
    padding: 0.5rem;
    font-size: 1rem;
    border-radius: 4px;
    border: none;
  }

  input {
    width: 60%;
    margin-right: 0.5rem;
  }

  button {
    background: #d7a6ff;
    color: #2c0b33;
    font-weight: bold;
    cursor: pointer;
  }
</style>
<script>
(function(){
  const picker = document.getElementById('voiceSelect');
  let voices = [];

  // Helper: always read the checkbox live
  function speakEnabled(){
    const tgl = document.getElementById('voiceToggle');
    return !!(tgl && tgl.checked);
  }

  // Load voices + preselect a warm one
  function loadVoices(){
    voices = speechSynthesis.getVoices();
    picker.innerHTML = '';
    voices.forEach((v,i)=>{
      const opt = document.createElement('option');
      opt.value = i;
      opt.textContent = `${v.name} — ${v.lang}`;
      picker.appendChild(opt);
    });
    // prefer Hayley, then Aria/Libby, then any Natural US/GB
    let idx = voices.findIndex(v => /Hayley.*Natural/i.test(v.name));
    if (idx < 0) idx = voices.findIndex(v => /(Aria|Libby).*Natural/i.test(v.name));
    if (idx < 0) idx = voices.findIndex(v => /(Natural).*(en-US|en-GB)/i.test(v.name+v.lang));
    if (idx >= 0) picker.value = idx;
  }
  loadVoices();
  window.speechSynthesis.onvoiceschanged = loadVoices;

  // Cancel immediately when toggled off
  const tgl = document.getElementById('voiceToggle');
  if (tgl) tgl.addEventListener('change', e => {
    if (!e.target.checked) speechSynthesis.cancel();
  });

  // Gentle text massage
  function softenText(t){
    t = t.replace(/ — /g, ' … ');
    if (!/[.?!…]$/.test(t.trim())) t = t.trim() + '.';
    return t.replace(/\s+/g,' ').trim();
  }

  function speak(text){
    if (!window.speechSynthesis || !speakEnabled()) return;

    const s = softenText(text);
    text = text.replace(/[,;:]/g, ', …');
    const parts = s.split(/(?<=[.?!…:;])\s+/); // phrases
    let i = 0;

    function queueNext(){
      if (!speakEnabled()) { speechSynthesis.cancel(); return; }
      if (i >= parts.length) return;
      
      if (i === 0) { setTimeout(() => queueNext(), 250); return; }

      const phrase = parts[i++];
      const u = new SpeechSynthesisUtterance(phrase);
      const v = voices[picker.value|0];
      if (v) u.voice = v;

      // Softer cadence
      let rate = 0.78, pitch = 0.94;
      if (/\?$/.test(phrase)) { rate = 0.88; pitch = 1.02; }
      if (/[.…]$/.test(phrase)) { rate = 0.80; pitch = 0.95; }
      u.rate = rate; u.pitch = pitch; u.volume = 0.88;

      u.onend = () => setTimeout(queueNext, 400);
      speechSynthesis.speak(u);
    }

    speechSynthesis.cancel(); // don’t stack with previous
    queueNext();
  }

  // expose to your render pipeline
  window.sanctumSpeakTharnel = speak;
})();
</script>

{% endblock %}
